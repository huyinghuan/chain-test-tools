// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: syscontract/cross_transaction.proto

package syscontract

import (
	fmt "fmt"
	proto "github.com/gogo/protobuf/proto"
	io "io"
	math "math"
	math_bits "math/bits"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion3 // please upgrade the proto package

type CrossTransactionFunction int32

const (
	// transaction execute
	CrossTransactionFunction_EXECUTE CrossTransactionFunction = 0
	// transaction commit
	CrossTransactionFunction_COMMIT CrossTransactionFunction = 1
	// transaction rollback
	CrossTransactionFunction_ROLLBACK CrossTransactionFunction = 2
	// read cross id state
	CrossTransactionFunction_READ_STATE CrossTransactionFunction = 3
	// save cross other transaction proof
	CrossTransactionFunction_SAVE_PROOF CrossTransactionFunction = 4
	// read cross other transaction proof
	CrossTransactionFunction_READ_PROOF CrossTransactionFunction = 5
	// arbitrate the cross transaction
	CrossTransactionFunction_ARBITRATE CrossTransactionFunction = 6
)

var CrossTransactionFunction_name = map[int32]string{
	0: "EXECUTE",
	1: "COMMIT",
	2: "ROLLBACK",
	3: "READ_STATE",
	4: "SAVE_PROOF",
	5: "READ_PROOF",
	6: "ARBITRATE",
}

var CrossTransactionFunction_value = map[string]int32{
	"EXECUTE":    0,
	"COMMIT":     1,
	"ROLLBACK":   2,
	"READ_STATE": 3,
	"SAVE_PROOF": 4,
	"READ_PROOF": 5,
	"ARBITRATE":  6,
}

func (x CrossTransactionFunction) String() string {
	return proto.EnumName(CrossTransactionFunction_name, int32(x))
}

func (CrossTransactionFunction) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_3776f52514f95871, []int{0}
}

type CrossTxState int32

const (
	//NON_EXIST cross id is not exist
	CrossTxState_NON_EXIST CrossTxState = 0
	//INIT just mark this cross is has been processed
	CrossTxState_INIT CrossTxState = 1
	//EXECUTE_OK cross tx execute successfully
	CrossTxState_EXECUTE_OK CrossTxState = 2
	//EXECUTE_FAIL cross tx execute fail
	CrossTxState_EXECUTE_FAIL CrossTxState = 3
	//COMMIT_OK cross tx commit successfully
	CrossTxState_COMMIT_OK CrossTxState = 4
	//COMMIT_FAIL cross tx commit fail
	CrossTxState_COMMIT_FAIL CrossTxState = 5
	//ROLLBACK_OK cross tx rollback successfully
	CrossTxState_ROLLBACK_OK CrossTxState = 6
	//ROLLBACK_FAIL cross tx rollback fail
	CrossTxState_ROLLBACK_FAIL CrossTxState = 7
)

var CrossTxState_name = map[int32]string{
	0: "NON_EXIST",
	1: "INIT",
	2: "EXECUTE_OK",
	3: "EXECUTE_FAIL",
	4: "COMMIT_OK",
	5: "COMMIT_FAIL",
	6: "ROLLBACK_OK",
	7: "ROLLBACK_FAIL",
}

var CrossTxState_value = map[string]int32{
	"NON_EXIST":     0,
	"INIT":          1,
	"EXECUTE_OK":    2,
	"EXECUTE_FAIL":  3,
	"COMMIT_OK":     4,
	"COMMIT_FAIL":   5,
	"ROLLBACK_OK":   6,
	"ROLLBACK_FAIL": 7,
}

func (x CrossTxState) String() string {
	return proto.EnumName(CrossTxState_name, int32(x))
}

func (CrossTxState) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_3776f52514f95871, []int{1}
}

type CrossArbitrateCmd int32

const (
	//AUTO_CMD automatic processing according to the process
	CrossArbitrateCmd_AUTO_CMD CrossArbitrateCmd = 0
	//EXECUTE_CMD execute the execution flow
	CrossArbitrateCmd_EXECUTE_CMD CrossArbitrateCmd = 1
	//COMMIT_CMD execute the commit flow
	CrossArbitrateCmd_COMMIT_CMD CrossArbitrateCmd = 2
	//COMMIT_CMD execute the rollback flow
	CrossArbitrateCmd_ROLLBACK_CMD CrossArbitrateCmd = 3
)

var CrossArbitrateCmd_name = map[int32]string{
	0: "AUTO_CMD",
	1: "EXECUTE_CMD",
	2: "COMMIT_CMD",
	3: "ROLLBACK_CMD",
}

var CrossArbitrateCmd_value = map[string]int32{
	"AUTO_CMD":     0,
	"EXECUTE_CMD":  1,
	"COMMIT_CMD":   2,
	"ROLLBACK_CMD": 3,
}

func (x CrossArbitrateCmd) String() string {
	return proto.EnumName(CrossArbitrateCmd_name, int32(x))
}

func (CrossArbitrateCmd) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_3776f52514f95871, []int{2}
}

type CrossState struct {
	State CrossTxState `protobuf:"varint,1,opt,name=state,proto3,enum=syscontract.CrossTxState" json:"state,omitempty"`
}

func (m *CrossState) Reset()         { *m = CrossState{} }
func (m *CrossState) String() string { return proto.CompactTextString(m) }
func (*CrossState) ProtoMessage()    {}
func (*CrossState) Descriptor() ([]byte, []int) {
	return fileDescriptor_3776f52514f95871, []int{0}
}
func (m *CrossState) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *CrossState) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_CrossState.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *CrossState) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CrossState.Merge(m, src)
}
func (m *CrossState) XXX_Size() int {
	return m.Size()
}
func (m *CrossState) XXX_DiscardUnknown() {
	xxx_messageInfo_CrossState.DiscardUnknown(m)
}

var xxx_messageInfo_CrossState proto.InternalMessageInfo

func (m *CrossState) GetState() CrossTxState {
	if m != nil {
		return m.State
	}
	return CrossTxState_NON_EXIST
}

func init() {
	proto.RegisterEnum("syscontract.CrossTransactionFunction", CrossTransactionFunction_name, CrossTransactionFunction_value)
	proto.RegisterEnum("syscontract.CrossTxState", CrossTxState_name, CrossTxState_value)
	proto.RegisterEnum("syscontract.CrossArbitrateCmd", CrossArbitrateCmd_name, CrossArbitrateCmd_value)
	proto.RegisterType((*CrossState)(nil), "syscontract.CrossState")
}

func init() {
	proto.RegisterFile("syscontract/cross_transaction.proto", fileDescriptor_3776f52514f95871)
}

var fileDescriptor_3776f52514f95871 = []byte{
	// 392 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0x4c, 0x92, 0x4d, 0xcf, 0xd2, 0x40,
	0x1c, 0xc4, 0xbb, 0x02, 0x05, 0xff, 0xbc, 0xb8, 0xec, 0x09, 0x0f, 0x36, 0x46, 0x2f, 0x86, 0xc4,
	0x36, 0xc1, 0xb3, 0x87, 0xa5, 0x94, 0xa4, 0x11, 0xa8, 0x69, 0x17, 0x43, 0xbc, 0x34, 0x6d, 0x25,
	0x95, 0x18, 0xba, 0x64, 0xbb, 0x1a, 0xbd, 0xf9, 0x05, 0x4c, 0xfc, 0x58, 0x1e, 0x39, 0x7a, 0x7c,
	0x02, 0x5f, 0xe4, 0xc9, 0x6e, 0x79, 0xe9, 0xa9, 0x9d, 0x99, 0x5f, 0x77, 0xa6, 0x69, 0xe1, 0x75,
	0xf9, 0xab, 0xcc, 0x78, 0x21, 0x45, 0x92, 0x49, 0x27, 0x13, 0xbc, 0x2c, 0x63, 0x29, 0x92, 0xa2,
	0x4c, 0x32, 0xb9, 0xe3, 0x85, 0x7d, 0x10, 0x5c, 0x72, 0xd2, 0xad, 0x41, 0xaf, 0xde, 0x03, 0xb8,
	0x8a, 0x8b, 0x64, 0x22, 0xb7, 0xc4, 0x81, 0x56, 0xa9, 0x6e, 0x46, 0xe8, 0x25, 0x7a, 0x33, 0x98,
	0x3c, 0xb7, 0x6b, 0xa8, 0xad, 0x39, 0xf6, 0x53, 0x93, 0x61, 0xc5, 0x8d, 0x7f, 0x23, 0x18, 0x55,
	0xfe, 0xbd, 0x66, 0xfe, 0xbd, 0xd0, 0x57, 0xd2, 0x85, 0xb6, 0xb7, 0xf1, 0xdc, 0x35, 0xf3, 0xb0,
	0x41, 0x00, 0x4c, 0x37, 0x58, 0x2e, 0x7d, 0x86, 0x11, 0xe9, 0x41, 0x27, 0x0c, 0x16, 0x8b, 0x29,
	0x75, 0x3f, 0xe0, 0x27, 0x64, 0x00, 0x10, 0x7a, 0x74, 0x16, 0x47, 0x8c, 0x32, 0x0f, 0x37, 0x94,
	0x8e, 0xe8, 0x27, 0x2f, 0xfe, 0x18, 0x06, 0xc1, 0x1c, 0x37, 0x6f, 0x79, 0xa5, 0x5b, 0xa4, 0x0f,
	0x4f, 0x69, 0x38, 0xf5, 0x59, 0xa8, 0x70, 0x73, 0xfc, 0x07, 0x41, 0xaf, 0x3e, 0x4d, 0xe5, 0xab,
	0x60, 0x15, 0x7b, 0x1b, 0x3f, 0x62, 0xd8, 0x20, 0x1d, 0x68, 0xfa, 0x2b, 0x5d, 0x3b, 0x00, 0xb8,
	0xec, 0x89, 0x03, 0x55, 0x8c, 0xa1, 0x77, 0xd5, 0x73, 0xea, 0x2f, 0x70, 0x43, 0x3d, 0x5a, 0x8d,
	0x54, 0x40, 0x93, 0x3c, 0x83, 0xee, 0x45, 0xea, 0xbc, 0xa5, 0x8c, 0xeb, 0x70, 0x45, 0x98, 0x64,
	0x08, 0xfd, 0x9b, 0xa1, 0x99, 0xf6, 0x98, 0xc1, 0x50, 0xcf, 0xa1, 0x22, 0xdd, 0x49, 0x91, 0xc8,
	0xad, 0xbb, 0xff, 0xa2, 0xde, 0x98, 0xae, 0x59, 0x10, 0xbb, 0xcb, 0x19, 0x36, 0xd4, 0x31, 0xd7,
	0x62, 0x65, 0xe8, 0x65, 0x97, 0x22, 0xa5, 0xf5, 0xb2, 0xdb, 0xb1, 0xca, 0x69, 0x4c, 0xf3, 0x7f,
	0x27, 0x0b, 0x1d, 0x4f, 0x16, 0x7a, 0x38, 0x59, 0xe8, 0xef, 0xd9, 0x32, 0x8e, 0x67, 0xcb, 0xf8,
	0x7f, 0xb6, 0x0c, 0x78, 0xc1, 0x45, 0x6e, 0x67, 0x5f, 0x93, 0x5d, 0xb1, 0x4f, 0xbe, 0x6d, 0x85,
	0x7d, 0x48, 0xeb, 0x5f, 0xed, 0x73, 0x3d, 0xe2, 0x22, 0x77, 0xee, 0xd2, 0x39, 0xa4, 0x6f, 0x73,
	0xee, 0xfc, 0x98, 0x38, 0x35, 0x3e, 0x35, 0xf5, 0x4f, 0xf2, 0xee, 0x31, 0x00, 0x00, 0xff, 0xff,
	0x02, 0x6b, 0xd7, 0xb9, 0x4b, 0x02, 0x00, 0x00,
}

func (m *CrossState) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CrossState) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *CrossState) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.State != 0 {
		i = encodeVarintCrossTransaction(dAtA, i, uint64(m.State))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func encodeVarintCrossTransaction(dAtA []byte, offset int, v uint64) int {
	offset -= sovCrossTransaction(v)
	base := offset
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return base
}
func (m *CrossState) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.State != 0 {
		n += 1 + sovCrossTransaction(uint64(m.State))
	}
	return n
}

func sovCrossTransaction(x uint64) (n int) {
	return (math_bits.Len64(x|1) + 6) / 7
}
func sozCrossTransaction(x uint64) (n int) {
	return sovCrossTransaction(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *CrossState) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCrossTransaction
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CrossState: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CrossState: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field State", wireType)
			}
			m.State = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCrossTransaction
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.State |= CrossTxState(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipCrossTransaction(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthCrossTransaction
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipCrossTransaction(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	depth := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowCrossTransaction
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowCrossTransaction
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
		case 1:
			iNdEx += 8
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowCrossTransaction
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if length < 0 {
				return 0, ErrInvalidLengthCrossTransaction
			}
			iNdEx += length
		case 3:
			depth++
		case 4:
			if depth == 0 {
				return 0, ErrUnexpectedEndOfGroupCrossTransaction
			}
			depth--
		case 5:
			iNdEx += 4
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
		if iNdEx < 0 {
			return 0, ErrInvalidLengthCrossTransaction
		}
		if depth == 0 {
			return iNdEx, nil
		}
	}
	return 0, io.ErrUnexpectedEOF
}

var (
	ErrInvalidLengthCrossTransaction        = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowCrossTransaction          = fmt.Errorf("proto: integer overflow")
	ErrUnexpectedEndOfGroupCrossTransaction = fmt.Errorf("proto: unexpected end of group")
)
